####################
# Tasks to resolve #
####################

Bootstrap et Preprocess risque de se recouvrer dans certains cas :
    - comment éviter cela si la stratégie execute les 2 méthodes ?
    - le bootstrap devrait être retiré au profit d'une initialisation des signaux
        - utilisant le depth normal, pas d'history comme ça
            - on a bourricot, firebird et scalpspectre qui bootstrap
                - bourricot : c'est juste pour détecter les pullback, ça peu se faire sans état, et pas utile pour les CVP
                - scalpspectre : pas besoin car c'est pour du scalp et est abandonné
                - firebird : pareil que pour bourricot on peu calculer les flags autrement
            => une méthode bootstrap mais qui ne rejout pas les candles :
                - ce qui en plus évite les imprécisions de ce pseudo replay

- bootstrapping alphaprocess pourrait se faire en tick surtout quand il n'y a pas d'historique en DB
   - on peut pas déterminer la période pour des non-temporals bar, donc obligé d'avoir une période arbitraire
       - un param dans la config en plus
   - à partir d'un tickstreamer procéder au bootstrapping

Sum order :
  - si spot : sum base (au moins sum pour EUR et USD), pour et eviter le rejet de l'API si qty insuffisante
        - attention à l'arrondit pour que ça ne bloque pas un autre order
        - le faire sur le watcher, lors d'order event, générer le asset update signal, locked/free
        - le faire sur le trader lors du __fetch_assets
        - si pas de leverage, ok ok est bien spot, sinon ignorer
        - si buy :
            - base free - volume executé en quote
            - quote -free +lock mais oter le volume executé
            - asset update signal
        - si sell :
            - base -free +lock mais oter le volume executé
            - quote free + volume executé en quote
            - asset update signal

- option --spec=profile-for-account:\<account-id\> pour supprimer les data de strategy

- dans le cadre du reduce :
    base trader : OK (tester)
    position trade : OK (tester)
    position : update profit and loss doit tenir compte du realized PNL

    position paper trader : doit ajuster le prix de sortie moyen en case de reduce mais aussi de close apres reduce

    ind margin paper trader : idem
    strategy ind margin trade : idem

    margin trader : idem mais n'est plus utilisé
    strategy margin trade : idem mais n'est plus utilisé

- gérer certains indicateur qui fonctionnement uniquement ou en partie avec des timeserie et non pas de tickbar/rangebar
 - cas de ATRSR
 - on ajoute un IDX sur chaque bar, mais ca ne suffit pas car il faudra alors aussi transmettre les series d'idx ou au moins
   le premier et dernier idx de chaque compute


#######
# WIP #
#######

- Refactoring StrategyTrader ou créer un StrategyTraderStd :
     c'est presque toujours pareil pour les : def on_market_info(self):
     pareil pour les : def filter_market(self, timestamp: float) -> Tuple[bool, bool]:
     presque pareil pour les price epsilon mais on ne s'en sert plus vraiment
     presque pareil pour les process_entry
     les process_exit sont presque jamais utilisés
     et les def process(self, timestamp: float): sont presques les mêmes

- Ajouter une option pour creer un spread sur certain tick streamer quand le bid/ask n'est pas présent (cas bitmex par exemple)

- Dans la vue aggtrade ajouter un avg entry price et total qty par market

- kraken watcher et trader :
    - bug de reco perte d'information WS parfois (trade execution, order update...)
        - revoir que si besoin ownTrade pour signal ORDER_TRADED peut être aiderait
    - fetch des positions pour margin
    - fetch des trades history et calcule des prix d'entré moyen par asset mais c'est lourd
    - parfois certains messages sont pas garantie dans le WS donc on rate une sortie ou une entrée
       - les check automatique sont pertinent mais faut éviter de saturer l'API si beaucoup de trade distinct.
       - peut etre qu'il faut considérer que kraken c'est plutôt de l'invest que du trading et donc ajuster les stratégies
    - comment savoir si trade maker ou taker ?

- WebTrader
    - HTTP :
        - POST/GET reinvest-gain handler
        - POST/GET DCA handler
    - WS :
        - notify/wt-read strategy-trader context data
        - notify/wt-read strategy-trader regions hit
    - display dialog detail with :
        - read/modify affinity
        - read/modify max-trade
        - read/modify contexts
    - charting :
        - charting OHLC et ticks (streaming) + performance (WIP)
        - goto charting historique sur un trade passé
        - ticker WS, basé sur quoi ? trader ticker ? strategy instrument ?
            - plutôt sur le trader car pas besoin de surcharger encore le strategy trader
    - session expiry message to renew
    - toggle audio et alt sound alerts (et save conf)
    - listes :
        - trier par (% pnl+-, market+-, date+-, upnl+-)
        - paginer si list > 100 élements
    - menu + modal pour créer une alerte price-cross
    - menu + modal pour créer une range region
    - menu + modal pour créer une trend region
    - recevoir stream de bid/ask, abonnement/resiliation en vue graphique
    - calculer r:r sur open trade, calcule % et montant risqué selon stop-loss


########
# Bugs #
########

- connector IG après la pause du weekend ne réussit pas à se reconnecter automatiquement

- certains ordres avec binance ne sont pas retire du trader (oblige de reconnect pour purger la liste)
- les ordres d'entrées market restent avec IG (avec le compte démo)

- WebTrader : on ne peu pas faire des reduce de quantity < à 1 (avec TradePosition)
- WebTrader : Si on passe en pip au lieu de % ça n'affiche pas tjs bien la valeur selon le marché pour les modify SL / TP

- Supprimer le client chart une fois la version web réalisée, donc ce bug ne devrait plus être

- Problème sur le comptage de la quantité de sortie, et du prix moyen de sortie d'un trade
    - En effet si la sortie est effectué par plusieurs ordres dans le cas du filled et exec-price, pas de problème,
        tout s'ajoute, mais si on a que cumulative-filled et avg-price alors remplacer les valeurs comme sur
        le trade d'entré va écraser les valeurs liées au trades de sorties précédents.
        - Exemple un take-profit limit, mais mettons la quantité n'est pas fully-filled, et finalement intervient
            pour une raison (stop-loss, timeout) un ordre de sortie au market (qui va devoir cancel le premier ordre)
    - Donc gérer peut être 2 compteurs pour la sortie, un temporaire lié au trade de sortie actif, et le normal

- TD9 countdown a debug et tester


##########
# Urgent #
##########

- Finir le volume profile et le composite volume profile
    - Tester avec un plot bar CLI

- transaction/rollback sur strategy trader save (on save tout ou rien sinon c'est inconsistant)

- def update_exit_qty(order_exec): fixer le avg exit price car peut être sur plusieurs ordres de sortie

- auto unsubscribe chart at web client close
- auto unsubscribe charts when no web client connected on server

- paper-trader : base exchange rate parfois peut être calcule si le market necessaire est disponnible

- Verification des trades par la method check :
    - implementer order_info pour le trader bitmex et verifier
    - implementer order_info pour le trader ig et verifier
    - verifier order_info pour le trader binance
    - verifier order_info pour le trader kraken car des bug etrangent se produisent parfois
    - verifier order_info pour le trader binancefutures (plus possible pour l'instant)

- Dans les trades context (exits) utiliser le param num_bars si définie mais comment on fait le comptage relatif,
    il faut nécessaire un analyser pour savoir si last_closed est vrai

- On pourrait afficher un chart et ou tableau account samples (par jour) comme ça on voir la perf par journée

- Charting CLI :
    - ajouter le plot bar CLI
    - ajouter un display chart CLI pour un data-serie donné (une couleur par ligne)

- Dans la vue trades history on n'a pas les valeurs en pts.
    - Le report ne les calculant pas d'une part (SL, TP, MAE, MFE, ETD, RPNL)
    - D'autre part si on veut le calculer coté view on n'a pas le one_pip_means
        - Soit on calcule au moment de reporting soit on donner la valeur one_pip_means dans le rapport
        - Dans le second cas on pourrait peut être faire de même pour active trades et calculer les valeurs pips
          coté view aussi. Cette approche semble préférable et uniforme.


##################
# Uniformization #
##################

- Move from siis.py for the resting command part to command_handler

- Finir les conversion des tools avec le model Tool (binarizer, fetcher, optimizer)

- close_position and modify_position must return Order REASON code in place of boolean

- Uniformiser l'order book (bitmex, binance, binancefutures, kraken)
    - avoir un object OrderBook facile à mettre à jour et à exploiter
    - utiliser DepthCacheManager pour binance et binancefutures

- Gérer la partie locked sur le paper trader en mode asset
    - ne pas tout gérer en free, peu important car ça n'empêche pas de fonctionner

- Peut etre serait il pertinant de renommer les Sub en DataSerie

- Dans les profiles tickbars et confusant car il fait mention aux range-bars actuellement
    - Soit on renomme, avec toutes les configs
    - Soit on précise avec les options qu'il s'agit de range-bar ou autre avec tickbar restant générique

- Est-il possible de merger timeframe+range-bar+session-bar... au sein du même strategytrader :
    - Dans l'absolu oui mais le bootstrap pose un problème car il devient encore plus complexe
    - Est ce qu'on a vraiment besoin de stratégie mélan plusieurs types de bar ?

- On retire de instrument les données de type bar :
    - Le strategy trader devient aussi generique et peut gérer des timeframe, range bar ou autre
        - Le fichier est déjà important... arranger cela
    - Les map timeframes et timeframes_streamers sont a merger


#########
# Bonus #
#########

- tool trainer :: run doit override les parameters markets specifics si presents

- Ne pas utiliser l'api-key/auth en paper-mode sur : kraken, bitmex, binance, binancefutures

- Ajouter TradeOp : TriggerEntry et TriggerLimitEntry, ainsi avoir le trigger coté bot,
    et ne pas bloquer les fonds coté broker

- non-temporal bars :
    - ajouter tick bar (t)
    - ajouter volume bar (v)
    - ajouter renko bar (voir https://tradewithpython.com/constructing-renko-charts-using-python exemple avec ATR) et %
    - ajouter unirenko bar (x,y,z)

- volumes indicators :
    - market profile indicator (+session offset/duration)
    - cumulative volume delta indicateur
    - ancienne tickbar => footprint et completer

- update to latest IG API

- emergency assets commands :
    - tool withdraw (ou command) simple avec pin code (2AF) paire et addresse
        - peut utiliser un alias d'adresse ou l'adresse enregistré par défaut (wallets.json)
        - montant de la transaction
    - tool withdraw emergency (ou command) qui annule tout les buy pending ou incomplet,
        et qui transfert sur les hard wallets (ou soft wallet)
    - tool withdraw emergency (ou command) comme précédente mais qui va revendre toutes les paires
        sur une seule de reference et ensuite transferer sur le le wallet de reference
            - la même mais avec un découpe en % sur N asset, et N wallet (hard ou soft)

############
## Divers ##
############

Server
------

- recup et intégration d'un int +1 ou -1 pour dire direction du trade (-bid, +ask)
- propagation de la dite info au stratégie
- stockage dans les fichiers trades avec en ASCII 1 ask 0 bid et en binaire un octet 1 ask 0 bid
- creation d'un tick bar avec nombre de tick par barre
- mesure des hedge zone sur tick bar
- mesure des balance bid ask par tick
- mesure des balance bid ask par tick bar
- mesure des volume imbalance par tick bar
- mesure des volume delta
- mesure en mode croisé bid x ask ou ask x bid
- parametrage des volume
- detection auto selon volume des précédentes tick bar pour ajuster les parametre des tick bar et autres seuils des indicateurs de mesure


Web Client
----------

- tracer timeframe bar, tick bar, range bar et reversal bar
- tracer volume bar
- tracer volume delta

- modify_take_profit / modify_stop_loss ammélioration :
    1) handler sur le strategytrader
    2) si modifie localement alors doit générer un notify update car il n'y aura pas de signal du broker
    3) si modifie et 'forced' (command) mais que asset trade et pas encore is_open alors danger de créer un ordre sur 0 qty or autre qty d'un autre trade
    4) utilisation du handler partout en lieu et place (strategies, command, operation)
    5) commnent gérer si has_xxx_order dans operation, dans command, autres cas... niveau handler ?


#################
## Data source ##
#################

- PyEX (mais c'est payant) => rapidapi-morningstar mais pas de WS
- polygon.io (99$ à 399$ / mois) => selon 1m ou tick, REST ou WS
- rapidapi-yahoo-finance pour récupérer stock, indices, forex quotes, mappinng à un autre broker (ig.com...) pour le prefetch
- rapidapi-morningstar pour récupérer les actions et indices intraday, D, W, M, mappinng à un autre broker (ig.com...) pour le prefetch
- RAPI(TM)
