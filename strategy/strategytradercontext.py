# @date 2019-01-13
# @author Frederic Scherma, All rights reserved without prejudices.
# @license Copyright (c) 2019 Dream Overflow
# Strategy trader context

from __future__ import annotations

from abc import ABC
from typing import TYPE_CHECKING, Optional, Union, Tuple

if TYPE_CHECKING:
    from strategy.strategysignal import StrategySignal
    from strategy.strategytraderbase import StrategyTraderBase
    from strategy.trade.strategytrade import StrategyTrade

from trader.order import Order
from instrument.instrument import Instrument

from common.utils import timeframe_from_str, timeframe_to_str

import logging

logger = logging.getLogger('siis.strategy.strategytradercontext')
error_logger = logging.getLogger('siis.error.strategy.strategytradercontext')
traceback_logger = logging.getLogger('siis.traceback.strategy.strategytradercontext')


class StrategyTraderContextBase(ABC):
    """
    Base model for any signal/trade context.

    More exactly this class serves internally to a StrategyTrader but must be explicitly completed.
    The old approach was to have signal generated by timeframe or tickbar sub @see StrategySub.
    But with this older approach computation are done per timeframe and could not combine different timeframe to
    fulfill a signal. In that case additional computations can be made to the strategy trader level but have no
    clean structure.

    Many context can be defined per strategy but generally the goal is to have a single one using multiple timeframe
    or tickbar sub.

    With this structure strategy sub only compute indicator and eventually some intermediate results.
    The context then implement the computation of the signal using different subs and parameters of the context that
    can be defined into the profile even auto-modified through the training algorithm.

    Entry, exit, trade management like breakeven, dynamic stop, dynamic target are defined per context @see EntryExit
    and inherited models.

    This class StrategyTraderContextBase is inherited by StrategyTraderContext. This is the common model to inherit
    from for a standard approach.

    StrategyTraderContextBase should not be inherited except if you really know what you do.
    """

    MODE_NONE = 0     # don't trade this context
    MODE_SIGNAL = 1   # produce only signal but never trade them
    MODE_TRADE = 2    # trade if possible the produced signals

    MODE = {
        'disabled': MODE_NONE,
        'none': MODE_NONE,
        'signal': MODE_SIGNAL,
        'enabled': MODE_TRADE,
        'trade': MODE_TRADE
    }

    @classmethod
    def type_name(cls) -> str:
        return ""

    def __init__(self):
        pass

    def dumps(self) -> dict:
        """
        Return a dict with currency parameters and stats of the context.
        It is used for the persistence (database) or by external trading tools (Web trader).
        database version store at the last save/exit.
        """
        return dict()

    def loads(self, strategy_trader, params: dict):
        """
        Load every parameter from local configuration (can be loaded from profile json file or from manual user update
        or from auto update when training).

        @param strategy_trader:
        @param params:
        @return:
        """
        pass


class EntryExit(object):
    """
    Entry exit base model used by a context @see StrategyTraderContext.
    @note Either timeframe or tickbar must be defined.
    """

    EX_UNDEFINED = 0     # Undefined type
    EX_ENTRY = 1         # Defines the context for the entry
    EX_TAKE_PROFIT = 2   # Defines the context for the target and for a dynamic take profit
    EX_STOP_LOSS = 3     # Defines the context for the stop loss and for a dynamic (trailing) stop
    EX_BREAKEVEN = 4     # Define the rules for the breakeven

    @classmethod
    def ex(cls) -> int:
        return cls.EX_UNDEFINED

    @classmethod
    def name(cls) -> str:
        """
        String version of the type of class.
        @return:
        """
        if cls.ex() == cls.EX_ENTRY:
            return "entry"
        elif cls.ex() == cls.EX_TAKE_PROFIT:
            return "take-profit"
        elif cls.ex() == cls.EX_STOP_LOSS:
            return "stop-loss"
        elif cls.ex() == cls.EX_BREAKEVEN:
            return "breakeven"
        else:
            return "undefined"

    def __init__(self):
        self.type = StrategyTraderContext.PRICE_NONE

        self.timeframe = 0.0   # 0 or a timeframe duration. each new bar of this timeframe a consolidated is then true
        self.num_bars = 0      # 0 or similar as timeframe duration, but it is a count in number of bars (range-bar...)

        self.timeout = 0.0   # timeout of the entry or exit order

        self.distance_value = None  # internal usage only during compilation of the context parameters
        self.distance = 0.0         # distance in percentile or price delta
        self.distance_type = StrategyTraderContext.PRICE_NONE  # defines the type of distance

        self.timeout_distance_value = None  # internal usage only during compilation of the context parameters
        self.timeout_distance = 0.0         # distance in percentile or price delta for the timeout
        self.timeout_distance_type = StrategyTraderContext.PRICE_NONE  # defines the type of timeout_distance

        self.offset_value = None  # internal usage only during compilation of the context parameters
        self.offset = 0.0         # offset to add to price (stop on breakeven...) (positive mean in favor of profit)
        self.offset_type = StrategyTraderContext.DIST_NONE  # type of the distance (percentile or price delta)

        self._consolidated = True   # only True after the computation occurs on a bar consolidation (at its close)
        self._last_closed_timestamp = 0.0   # the timestamp when occurs the last consolidation (close)

        self.depth = 0       # related to level of depth of support or resistance but not mandatory
        self.orientation = StrategyTraderContext.ORIENTATION_BOTH  # related to the depth parameters

    def loads(self, strategy_trader, params: dict):
        if 'type' not in params or params.get('type') not in StrategyTraderContext.PRICE:
            raise ValueError("Undefined or unsupported 'type' value for %s" % self.name())

        self.type = StrategyTraderContext.PRICE.get(params['type'])
        self.timeframe = timeframe_from_str(params.get('timeframe', "t"))
        self.num_bars = params.get('num-bars', 0)

        if self.timeframe < 0:
            raise ValueError("Undefined or unsupported 'timeframe' value for %s" % self.name())

        if self.num_bars < 0:
            raise ValueError("Undefined or unsupported 'num-bars' value for %s" % self.name())

        if params.get('timeout'):
            # optional timeout
            self.timeout = timeframe_from_str(params.get('timeout', ""))

        # standard distance
        distance = params.get('distance', "0.0")
        if type(distance) is not str:
            raise ValueError("Invalid format 'distance' must be string for %s" % self.name())

        if distance is not None:
            if distance.endswith('%'):
                # in percent from entry price or limit price
                self.distance = float(distance[:-1]) * 0.01
                self.distance_type = StrategyTraderContext.DIST_PERCENTILE
            elif distance.endswith('pip'):
                # in pips from entry price or limit price
                self.distance_value = float(distance[:-3])
                self.distance_type = StrategyTraderContext.DIST_PRICE
            else:
                # in price from entry price or limit price
                self.distance = float(distance)
                self.distance_type = StrategyTraderContext.DIST_PRICE

        # timeout distance
        timeout_distance = params.get('timeout-distance', "0.0")
        if type(timeout_distance) is not str:
            raise ValueError("Invalid format 'timeout-distance' must be string for %s" % self.name())

        if timeout_distance is not None:
            if timeout_distance.endswith('%'):
                # in percent from entry price or limit price
                self.timeout_distance = float(timeout_distance[:-1]) * 0.01
                self.timeout_distance_type = StrategyTraderContext.DIST_PERCENTILE

            elif timeout_distance.endswith('pip'):
                # in pips from entry price or limit price
                self.timeout_distance_value = float(timeout_distance[:-3])
                self.timeout_distance_type = StrategyTraderContext.DIST_PRICE

            else:
                # in price from entry price or limit price
                self.timeout_distance = float(timeout_distance)
                self.timeout_distance_type = StrategyTraderContext.DIST_PRICE

        # standard offset
        offset = params.get('offset', "0.0")
        if type(offset) is not str:
            raise ValueError("Invalid format 'offset' must be string for %s" % self.name())

        if offset is not None:
            if offset.endswith('%'):
                # in percent from last price
                self.offset = float(offset[:-1]) * 0.01
                self.offset_type = StrategyTraderContext.DIST_PERCENTILE
            elif offset.endswith('pip'):
                # in pips from entry price or limit price
                self.offset_value = float(offset[:-3])
                self.offset_type = StrategyTraderContext.DIST_PRICE
            else:
                # in price from entry price or limit price
                self.offset = float(offset)
                self.offset_type = StrategyTraderContext.DIST_PRICE

        # some indicator need (like ATR-SR) need an orientation and a depth
        if self.type in (StrategyTraderContext.PRICE_ATR_SR,):
            if 'orientation' not in params or params.get('orientation') not in StrategyTraderContext.ORIENTATION:
                raise ValueError("Undefined or unsupported 'orientation' value for %s" % self.name())

            if 'depth' not in params:
                raise ValueError("Undefined 'depth' value for %s" % self.name())

        self.depth = params.get('depth', 0)
        self.orientation = StrategyTraderContext.ORIENTATION.get(params.get('orientation', 'both'))

    def dumps(self) -> dict:
        return {
            'type': self.type_to_str(),
            'timeframe': timeframe_to_str(self.timeframe),
            'num-bars': self.num_bars,
            'timeout': self.timeout,
            'timeout-distance': self.timeout_distance * 100 if self.timeout_distance_type == StrategyTraderContext.DIST_PERCENTILE else self.timeout_distance,
            'timeout-distance-type': "percent" if self.timeout_distance_type == StrategyTraderContext.DIST_PERCENTILE else "dist",
            'distance': self.distance * 100 if self.distance_type == StrategyTraderContext.DIST_PERCENTILE else self.distance,
            'distance-type': "percent" if self.distance_type == StrategyTraderContext.DIST_PERCENTILE else "dist",
            'offset': self.offset * 100 if self.offset_type == StrategyTraderContext.DIST_PERCENTILE else self.offset,
            'offset-type': "percent" if self.offset_type == StrategyTraderContext.DIST_PERCENTILE else "dist",
            'depth': self.depth,
            'orientation': self.orientation
        }

    def update(self, timestamp):
        """
        Must be called at each strategy trader computation to update internal values.
        @param timestamp: Current computation timestamp in seconds.
        """
        if self.timeframe > 0:
            self._consolidated = False
            if Instrument.basetime(self.timeframe, timestamp) > self._last_closed_timestamp:
                self._consolidated = True
                self._last_closed_timestamp = timestamp

        elif self.num_bars > 0:
            pass  # @todo

    def modify_distance(self, strategy_trader, distance):
        """
        User modification of the distance parameter.
        @param strategy_trader:
        @param distance: Could be a string or a float/int.
        """
        if type(distance) is str and distance.endswith('%'):
            # in percent from entry price or limit price
            self.distance = float(distance[:-1]) * 0.01
            self.distance_type = StrategyTraderContext.DIST_PERCENTILE

        elif type(distance) is str and distance.endswith('pip'):
            # in pips from entry price or limit price
            self.distance = float(distance[:-3]) * strategy_trader.instrument.one_pip_means
            self.distance_type = StrategyTraderContext.DIST_PRICE

        else:
            # in price from entry price or limit price
            self.distance = float(distance)
            self.distance_type = StrategyTraderContext.DIST_PRICE

    def modify_timeout_distance(self, strategy_trader, timeout_distance: str):
        """
        User modification of the timeout_distance parameter.
        @param strategy_trader:
        @param timeout_distance: Could be a string or a float/int.
        """
        if type(timeout_distance) is str and timeout_distance.endswith('%'):
            # in percent from entry price or limit price
            self.timeout_distance = float(timeout_distance[:-1]) * 0.01
            self.timeout_distance_type = StrategyTraderContext.DIST_PERCENTILE

        elif type(timeout_distance) is str and timeout_distance.endswith('pip'):
            # in pips from entry price or limit price
            self.timeout_distance = float(timeout_distance[:-3]) * strategy_trader.instrument.one_pip_means
            self.timeout_distance_type = StrategyTraderContext.DIST_PRICE

        else:
            # in price from entry price or limit price
            self.timeout_distance = float(timeout_distance)
            self.timeout_distance_type = StrategyTraderContext.DIST_PRICE

    def modify_offset(self, strategy_trader, offset):
        """
        User modification of the offset parameter.
        @param strategy_trader:
        @param offset: Could be a string or a float/int.
        """
        if type(offset) is str and offset.endswith('%'):
            # in percent from last price
            self.offset = float(offset[:-1]) * 0.01
            self.offset_type = StrategyTraderContext.DIST_PERCENTILE

        elif type(offset) is str and offset.endswith('pip'):
            # in pips from last price
            self.offset = float(offset[:-3]) * strategy_trader.instrument.one_pip_means
            self.offset_type = StrategyTraderContext.DIST_PRICE

        else:
            # in price from last price
            self.offset = float(offset)
            self.offset_type = StrategyTraderContext.DIST_PRICE

    def modify_orientation(self, orientation: str):
        """
        User modification of the orientation parameter.
        @param orientation: int 1 or -1 or 0 or const ORIENTATION_*.
        """
        self.orientation = StrategyTraderContext.ORIENTATION.get(orientation, StrategyTraderContext.ORIENTATION_UP)

    def distance_to_str(self, strategy_trader) -> str:
        """
        Return the distance parameter in its string format.
        @param strategy_trader:
        @return: str
        """
        if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
            return "%.2f%%" % (self.distance * 100.0)
        elif self.distance_type == StrategyTraderContext.DIST_PRICE:
            return strategy_trader.instrument.format_price(self.distance)
        else:
            return strategy_trader.instrument.format_price(self.distance)

    def timeout_distance_to_str(self, strategy_trader) -> str:
        """
        Return the timeout distance parameter in its string format.
        @param strategy_trader:
        @return: str
        """
        if self.timeout_distance_type == StrategyTraderContext.DIST_PERCENTILE:
            return "%.2f%%" % (self.timeout_distance * 100.0)
        elif self.timeout_distance_type == StrategyTraderContext.DIST_PRICE:
            return strategy_trader.instrument.format_price(self.timeout_distance)
        else:
            return strategy_trader.instrument.format_price(self.timeout_distance)

    def offset_to_str(self, strategy_trader) -> str:
        """
        Return the offset parameter in its string format.
        @param strategy_trader:
        @return: str
        """
        if self.offset_type == StrategyTraderContext.DIST_PERCENTILE:
            return "%.2f%%" % (self.offset * 100.0)
        elif self.offset_type == StrategyTraderContext.DIST_PRICE:
            return strategy_trader.instrument.format_price(self.offset)
        else:
            return strategy_trader.instrument.format_price(self.offset)

    def orientation_to_str(self) -> str:
        """
        Return the orientation parameter in its string format.
        @return: str
        """
        return StrategyTraderContext.ORIENTATION_FROM_STR_MAP.get(self.orientation)

    def type_to_str(self):
        """
        Return the price type parameter in its string format.
        @return: str
        """
        return StrategyTraderContext.PRICE_FROM_STR_MAP.get(self.type)

    def compile(self, strategy_trader):
        # standard distance
        if self.distance_value is not None:
            if self.distance_type == StrategyTraderContext.DIST_PRICE:
                # because instrument details are guarantee only at compile time
                self.distance = self.distance_value * strategy_trader.instrument.one_pip_means

        # timeout distance
        if self.timeout_distance_value is not None:
            if self.timeout_distance_type == StrategyTraderContext.DIST_PRICE:
                # because instrument details are guarantee only at compile time
                self.timeout_distance = self.timeout_distance_value * strategy_trader.instrument.one_pip_means

        # offset distance
        if self.offset_value is not None:
            if self.offset_type == StrategyTraderContext.DIST_PRICE:
                # because instrument details are guarantee only at compile time
                self.offset = self.offset_value * strategy_trader.instrument.one_pip_means

    @property
    def update_at_close(self) -> bool:
        """
        Meaning that that behavior must be applied at the close of the specified timeframe.
        If no timeframe or 0 it means that behavior is computed each time.
        """
        return self.timeframe == 0.0

    @property
    def consolidated(self) -> bool:
        """
        Return True when the context update occurs on a closed timeframe. Exemple if timeframe is defined to 300
        (5 minutes), this will return True every 5 minutes.
        @return: True if the bar just consolidate.
        """
        if self.timeframe > 0.0:
            return self._consolidated

        if self.num_bars > 0:
            return True  # @todo for num-bar self._consolidated

        return True


class EXEntry(EntryExit):
    """
    Entry context for signal.
    """

    @classmethod
    def ex(cls) -> int:
        return cls.EX_ENTRY

    def __init__(self):
        super().__init__()

        self.max_spread_value = None
        self.max_spread = 0.0

    def loads(self, strategy_trader, params: dict):
        super().loads(strategy_trader, params)

        # mandatory timeout
        if not self.timeout:
            raise ValueError("Undefined or unsupported 'timeout' value for %s" % self.name())

        # max-spread
        max_spread = params.get('max-spread', "0.0")
        if max_spread is not None:
            if type(max_spread) in (float, int):
                # value in delta price
                self.max_spread = max_spread
            elif type(max_spread) is str:
                if max_spread.endswith('pip'):
                    # value in pips
                    self.max_spread_value = float(max_spread[:-3])
                else:
                    # in delta price
                    self.max_spread = float(max_spread)
            else:
                raise ValueError("Invalid format 'max-spread' must be string, int or float for %s" % self.name())

    def compile(self, strategy_trader):
        super().compile(strategy_trader)

        # max-spread
        if self.max_spread_value is not None:
            # value in pips
            self.max_spread = self.max_spread_value * strategy_trader.instrument.one_pip_means

    def dumps(self) -> dict:
        return super().dumps()

    def check_spread(self, instrument: Instrument) -> bool:
        """Compare spread from entry signal max allowed spread value, only if max-spread parameters is valid"""
        if self.max_spread <= 0.0:
            return True

        return instrument.market_spread <= self.max_spread

    def compute_entry(self, instrument: Instrument, signal: StrategySignal):
        """
        Compute a standard entry price and order type according to configured entry type.
        @note signal direction must be defined before.
        """
        if not instrument or not signal:
            return

        if self.type == StrategyTraderContext.PRICE_LAST:
            signal.price = instrument.open_exec_price(signal.direction)
            signal.order_type = Order.ORDER_MARKET
        elif self.type == StrategyTraderContext.PRICE_BEST1:
            signal.order_type = Order.ORDER_LIMIT
            signal.price = instrument.open_exec_price(signal.direction, True)
        elif self.type == StrategyTraderContext.PRICE_BEST2:
            signal.order_type = Order.ORDER_LIMIT
            signal.price = instrument.open_exec_price(signal.direction, True) - signal.direction * instrument.market_spread
        elif self.type == StrategyTraderContext.PRICE_FIXED:
            signal.order_type = Order.ORDER_LIMIT
            if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                signal.price = instrument.open_exec_price(signal.direction) * (1.0 - signal.direction * self.distance)
            elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                signal.price = instrument.open_exec_price(signal.direction) - signal.direction * self.distance


class EXTakeProfit(EntryExit):
    """
    Target take-profit context for signal. Also used for dynamic-take-profit.
    """
    @classmethod
    def ex(cls) -> int:
        return cls.EX_TAKE_PROFIT

    def __init__(self):
        super().__init__()

    @staticmethod
    def percentile_distance_from_limit(signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Return in percentile the distance from a price (could be close execution price) and trade take profit price.
        @note The distance is oriented by the direction (a profitable price returns a positive value).
        """
        if signal_or_trade.take_profit > 0.0:
            return signal_or_trade.direction * (signal_or_trade.take_profit - price) / price

        return 0.0

    @staticmethod
    def price_distance_from_limit(signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Return the distance from a price (could be close execution price) and trade take profit price.
        @note The distance is oriented by the direction (a profitable price returns a positive value).
        """
        if signal_or_trade.take_profit > 0.0:
            return signal_or_trade.direction * (signal_or_trade.take_profit - price)

        return 0.0

    def check_min_distance_from_limit(self, signal_or_trade: Union[StrategyTrade, StrategySignal], price: float) -> bool:
        """
        Check if the minimal distance price to take-profit is respected.
        @param signal_or_trade: Valid trade or signal.
        @param price: Current price
        @return:
        """
        if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
            return EXTakeProfit.percentile_distance_from_limit(signal_or_trade, price) >= self.distance

        elif self.distance_type == StrategyTraderContext.DIST_PRICE:
            return EXTakeProfit.price_distance_from_limit(signal_or_trade, price) >= self.distance

        return False

    def clamp_limit(self, signal: StrategySignal):
        """
        Take profit must not exceed his configured distance.
        @param signal: Strategy signal
        """
        if signal and self.distance > 0.0:
            if signal.direction > 0:
                # long case
                if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                    if signal.take_profit <= 0.0 or self.percentile_distance_from_limit(
                            signal, signal.entry_price) > self.distance:
                        signal.take_profit = signal.entry_price * (1.0 + self.distance)

                elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                    if signal.take_profit <= 0.0 or self.price_distance_from_limit(
                            signal, signal.entry_price) > self.distance:
                        signal.take_profit = signal.entry_price + self.distance

            elif signal.direction < 0:
                # short case
                if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                    if signal.take_profit <= 0.0 or self.percentile_distance_from_limit(
                            signal, signal.entry_price) > self.distance:
                        signal.take_profit = signal.entry_price * (1.0 - self.distance)

                elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                    if signal.take_profit <= 0.0 or self.price_distance_from_limit(
                            signal, signal.entry_price) > self.distance:
                        signal.take_profit = signal.entry_price - self.distance

    def take_profit_from_price(self, signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Compute the fixed take-profit price for a trade or signal from distance to given price.
        And return the computed value.
        @param signal_or_trade:
        @param price: Last close execution price or any other price.
        @return: The price of the take-profit or 0 if not defined.
        @note The take-profit price can never be lower in long or higher in short than the current signal or
        trade take-profit price.
        Except if the current value is not defined (take_profit_price = 0)
        """
        if self.type == StrategyTraderContext.PRICE_FIXED and self.distance > 0.0:
            if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                if signal_or_trade.direction > 0:
                    take_profit_price = price * (1.0 + self.distance)
                    if signal_or_trade.take_profit == 0.0 or take_profit_price >= signal_or_trade.take_profit:
                        return take_profit_price

                elif signal_or_trade.direction < 0:
                    take_profit_price = price * (1.0 - self.distance)
                    if signal_or_trade.take_profit == 0.0 or take_profit_price <= signal_or_trade.take_profit:
                        return take_profit_price

            elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                if signal_or_trade.direction > 0:
                    take_profit_price = price + self.distance
                    if signal_or_trade.take_profit == 0.0 or take_profit_price >= signal_or_trade.take_profit:
                        return take_profit_price

                elif signal_or_trade.direction < 0:
                    take_profit_price = price - self.distance
                    if signal_or_trade.take_profit == 0.0 or take_profit_price <= signal_or_trade.take_profit:
                        return take_profit_price

    def compute_take_profit(self, signal: StrategySignal) -> float:
        """
        Compute the fixed take profit price for a signal. Entry price must be defined and direction too.
        @param signal:
        @return: The price of the take profit or 0 if not defined.
        """
        if self.type == StrategyTraderContext.PRICE_FIXED and self.distance > 0.0:
            if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                if signal.direction > 0:
                    signal.take_profit = signal.entry_price * (1.0 + self.distance)
                elif signal.direction < 0:
                    signal.take_profit = signal.entry_price * (1.0 - self.distance)

            elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                if signal.direction > 0:
                    signal.take_profit = signal.entry_price + self.distance
                elif signal.direction < 0:
                    signal.take_profit = signal.entry_price - self.distance

        return signal.take_profit

    def apply_initial_limit(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade, hard: bool = True):
        """
        When a limit price is defined on the order but only on the soft (locally) size. This method would help
        to force to apply the modification to the position or by creating a limit exit order at actual
        take profit price.

        @note Have no effect if a limit order is already defined or if the position already have a take profit price.
        """
        if not trade:
            return

        if trade.take_profit <= 0.0:
            return

        if trade.has_limit_order():
            return

        # initial take-profit to be applied on position or order
        initial_tp = strategy_trader.instrument.adjust_price(trade.tp)
        try:
            # apply as a distant order or position value
            strategy_trader.trade_modify_take_profit(trade, initial_tp, hard)
        except Exception as e:
            error_logger.error(repr(e))

    def loads(self, strategy_trader: StrategyTraderBase, params: dict):
        super().loads(strategy_trader, params)

    def dumps(self) -> dict:
        return super().dumps()


class EXStopLoss(EntryExit):
    """
    Exit stop-loss context for signal. Also used for dynamic-stop-loss.
    """
    @classmethod
    def ex(cls):
        return cls.EX_STOP_LOSS

    def __init__(self):
        super().__init__()

    @staticmethod
    def percentile_distance_from_stop(signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Return in percentile the distance from a price (could be close execution price) and trade stop loss price.
        @note The distance is oriented by the direction (a loosing price returns a positive value).
        """
        if signal_or_trade.stop_loss > 0.0:
            return signal_or_trade.direction * (price - signal_or_trade.stop_loss) / signal_or_trade.stop_loss

        return 0.0

    @staticmethod
    def price_distance_from_stop(signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Return the distance from a price (could be close execution price) and trade stop loss price.
        @note The distance is oriented by the direction (a loosing price returns a positive value).
        """
        if signal_or_trade.stop_loss > 0.0:
            return signal_or_trade.direction * (price - signal_or_trade.stop_loss)

        return 0.0

    def check_min_distance_from_stop(self, signal_or_trade: Union[StrategyTrade, StrategySignal], price: float) -> bool:
        """
        Check if the minimal distance price to stop is respected.
        @param signal_or_trade: Valid trade or signal.
        @param price: Current price
        @return:
        """
        if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
            return EXStopLoss.percentile_distance_from_stop(signal_or_trade, price) >= self.distance

        elif self.distance_type == StrategyTraderContext.DIST_PRICE:
            return EXStopLoss.price_distance_from_stop(signal_or_trade, price) >= self.distance

        return False

    def compute_stop_loss(self, signal: StrategySignal) -> float:
        """
        Compute the fixed stop loss price for a signal. Entry price must be defined and direction too.
        And set the value to the signal.
        @param signal:
        @return: The price of the stop loss or 0 if not defined.
        """
        if self.type == StrategyTraderContext.PRICE_FIXED and self.distance > 0.0:
            if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                if signal.direction > 0:
                    signal.stop_loss = signal.entry_price * (1.0 - self.distance)
                elif signal.direction < 0:
                    signal.stop_loss = signal.entry_price * (1.0 + self.distance)

            elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                if signal.direction > 0:
                    signal.stop_loss = signal.entry_price - self.distance
                elif signal.direction < 0:
                    signal.stop_loss = signal.entry_price + self.distance

        return signal.stop_loss

    def apply_initial_stop(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade, hard: bool = True):
        """
        When a stop price is defined on the order but only on the soft (locally) size. This method would help
        to force to apply the modification to the position or by creating a stop exit order at actual stop price.

        @note Have no effect if a stop order is already defined or if the position already have a stop price.
        """
        if not trade:
            return

        if trade.stop_loss <= 0.0:
            return

        if trade.has_stop_order():
            return

        # initial stop-loss to be applied on position or order
        if trade.support_both_order():
            initial_sl = strategy_trader.instrument.adjust_price(trade.stop_loss)
            try:
                # apply as a distant order or position value only if possible
                strategy_trader.trade_modify_stop_loss(trade, initial_sl, hard)
            except Exception as e:
                error_logger.error(repr(e))

    def stop_loss_from_price(self, signal_or_trade: Union[StrategySignal, StrategyTrade], price: float) -> float:
        """
        Compute the fixed stop loss price for a trade or signal from distance to given price.
        And return the computed value.
        @param signal_or_trade:
        @param price: Last close execution price or any other price.
        @return: The price of the stop loss or 0 if not defined.
        @note The stop price can never be lower in long or higher in short than the current signal or trade stop price.
        Except if the current value is not defined (stop_price = 0)
        """
        if self.type == StrategyTraderContext.PRICE_FIXED and self.distance > 0.0:
            if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                if signal_or_trade.direction > 0:
                    stop_price = price * (1.0 - self.distance)
                    if signal_or_trade.stop_loss == 0.0 or stop_price >= signal_or_trade.stop_loss:
                        return stop_price

                elif signal_or_trade.direction < 0:
                    stop_price = price * (1.0 + self.distance)
                    if signal_or_trade.stop_loss == 0.0 or stop_price <= signal_or_trade.stop_loss:
                        return stop_price

            elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                if signal_or_trade.direction > 0:
                    stop_price = price - self.distance
                    if signal_or_trade.stop_loss == 0.0 or stop_price >= signal_or_trade.stop_loss:
                        return stop_price

                elif signal_or_trade.direction < 0:
                    stop_price = price + self.distance
                    if signal_or_trade.stop_loss == 0.0 or stop_price <= signal_or_trade.stop_loss:
                        return stop_price

        return 0.0

    def clamp_stop(self, signal: StrategySignal):
        """
        Stop loss must not exceed the configured distance.
        @param signal: Strategy signal
        """
        if signal and self.distance > 0.0:
            if signal.direction > 0:
                # long case
                if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                    if signal.stop_loss <= 0.0 or self.percentile_distance_from_stop(
                            signal, signal.entry_price) > self.distance:
                        signal.stop_loss = signal.entry_price * (1.0 - self.distance)

                elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                    if signal.stop_loss <= 0.0 or self.price_distance_from_stop(
                            signal, signal.entry_price) > self.distance:
                        signal.stop_loss = signal.entry_price - self.distance

            elif signal.direction < 0:
                # short case
                if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
                    if signal.stop_loss <= 0.0 or self.percentile_distance_from_stop(
                            signal, signal.entry_price) > self.distance:
                        signal.stop_loss = signal.entry_price * (1.0 + self.distance)

                elif self.distance_type == StrategyTraderContext.DIST_PRICE:
                    if signal.stop_loss <= 0.0 or self.price_distance_from_stop(
                            signal, signal.entry_price) > self.distance:
                        signal.stop_loss = signal.entry_price + self.distance

    def loads(self, strategy_trader: StrategyTraderBase, params: dict):
        super().loads(strategy_trader, params)

    def dumps(self) -> dict:
        return super().dumps()


class EXBreakeven(EntryExit):
    """
    Breakeven context for signal. Affect the stop order.
    """
    @classmethod
    def ex(cls):
        return cls.EX_BREAKEVEN

    def __init__(self):
        super().__init__()

    @staticmethod
    def percentile_distance_from_entry(signal_or_trade, price: float) -> float:
        """
        Return in percentile the distance from a price (could be close execution price) and trade entry price.
        The distance is always a positive value.
        """
        if signal_or_trade.entry_price > 0.0:
            return signal_or_trade.direction * (price - signal_or_trade.entry_price) / signal_or_trade.entry_price

        return 0.0

    @staticmethod
    def price_distance_from_entry(signal_or_trade, price: float) -> float:
        """
        Return the distance from a price (could be close execution price) and trade entry price.
        The distance is always a positive value.
        """
        if signal_or_trade.entry_price > 0.0:
            return signal_or_trade.direction * (price - signal_or_trade.entry_price)

        return 0.0

    def check_min_distance_from_entry(self, signal_or_trade: Union[StrategyTrade, StrategySignal], price: float) -> bool:
        """
        Check if the minimal distance price to entry is respected.
        @note It is a gross distance that is compared (does not include fees and commissions).
        @param signal_or_trade: Valid trade or signal.
        @param price: Current price
        @return:
        """
        # original test use net worth (entry fees/commission and exit fees/commission estimation)
        # if trade.estimate_profit_loss_rate(strategy_trader.instrument) <= min_dist:

        if self.distance_type == StrategyTraderContext.DIST_PERCENTILE:
            return EXBreakeven.percentile_distance_from_entry(signal_or_trade, price) >= self.distance

        elif self.distance_type == StrategyTraderContext.DIST_PRICE:
            return EXBreakeven.price_distance_from_entry(signal_or_trade, price) >= self.distance

        return False

    def stop_loss_from_entry_price(self, signal_or_trade: Union[StrategySignal, StrategyTrade]) -> float:
        """
        Compute the fixed stop loss price for a trade or signal from distance to entry price.
        The offset is always applied in favor of the profit.
        And return the computed value.
        @param signal_or_trade:
        @return: The price of the stop loss or 0 if not defined.
        """
        if self.type == StrategyTraderContext.PRICE_FIXED and self.distance > 0.0:
            if self.offset_type == StrategyTraderContext.DIST_PERCENTILE:
                if signal_or_trade.direction > 0:
                    return signal_or_trade.entry_price * (1.0 + self.offset)
                elif signal_or_trade.direction < 0:
                    return signal_or_trade.entry_price * (1.0 - self.offset)

            elif self.offset_type == StrategyTraderContext.DIST_PRICE:
                if signal_or_trade.direction > 0:
                    return signal_or_trade.entry_price + self.offset
                elif signal_or_trade.direction < 0:
                    return signal_or_trade.entry_price - self.offset

        return 0.0

    def loads(self, strategy_trader, params: dict):
        super().loads(strategy_trader, params)

    def dumps(self) -> dict:
        return super().dumps()


class StrategyTraderContext(StrategyTraderContextBase):
    """
    Standard implementation of the context.
    This model should be inherited to implement compute_signal and eventually the update_trade methods.

    @note Only use the PRICE type 0 to 5. Others are deprecated and kept until older strategies are not upgraded.

    mode: Either compute nothing or only non-traded signal or to be traded signal.

    Trade quantity management : Different policy of quantity are possible :
        'normal': TRADE_QUANTITY_NORMAL, trade with a fixed size (can eventually be modified manually).
        'specific': TRADE_QUANTITY_SPECIFIC, trade with a quantity specified by the context.
        'reinvest-max-last': TRADE_QUANTITY_REINVEST_MAX_LAST, reinvest the profit of the best (higher) winner trade.
        'increment-step': TRADE_QUANTITY_INC_STEP, each time increment of a step of size.
        'managed': TRADE_QUANTITY_MANAGED, managed by an external policy  @see Handler and its different implementations

    max_trade: Maximum integer number of trade for this context only (but could not exceed max_trade configured at
    the strategy trader).

    min_profit: Float value in percentile that define the minimum percent of profit that a signal must target.
    A signal might be accepted only on this condition.

    long_call: Could define a dynamically registered method to call for compute a long signal.
    short_call: Could define a dynamically registered method to call for compute a short signal.
    Most of the case that does not need complex or multiple cases does not need of long_call and short_call.
    """

    PRICE_NONE = 0    # undefined
    PRICE_CUSTOM = 1  # custom method
    PRICE_FIXED = 2   # price at fixed distance in delta or percentile
    PRICE_LAST = 3    # last trade price
    PRICE_BEST1 = 4   # best first bid/ask price
    PRICE_BEST2 = 5   # best second bid/ask price
    # indicator based methods are deprecated. must be implemented by the strategy context
    PRICE_BOLLINGER = 6
    PRICE_ATR_SR = 7
    PRICE_CUR_ATR_SR = 8
    PRICE_HMA = 9
    PRICE_VOL_SR = 10

    DIST_NONE = 0
    DIST_PERCENTILE = 1
    DIST_PRICE = 2

    PRICE = {
        'none': PRICE_NONE,
        'custom': PRICE_CUSTOM,
        'fixed': PRICE_FIXED,
        'last': PRICE_LAST,
        'best+1': PRICE_BEST1,
        'best+2': PRICE_BEST2,
        'bollinger': PRICE_BOLLINGER,  # @deprecated, need custom
        'atrsr': PRICE_ATR_SR,  # @deprecated, need custom
        'cur-atrsr': PRICE_CUR_ATR_SR,  # @deprecated, need custom
        'hma': PRICE_HMA,  # @deprecated, need custom
        'vol-sr': PRICE_VOL_SR,  # @deprecated, need custom
    }

    PRICE_FROM_STR_MAP = {v: k for k, v in PRICE.items()}

    ORIENTATION_UP = 1
    ORIENTATION_DN = -1
    ORIENTATION_BOTH = 0

    ORIENTATION = {
        'up': ORIENTATION_UP,
        'upper': ORIENTATION_UP,
        'high': ORIENTATION_UP,
        'higher': ORIENTATION_UP,
        'dn': ORIENTATION_DN,
        'down': ORIENTATION_DN,
        'low': ORIENTATION_DN,
        'lower': ORIENTATION_DN,
        'both': ORIENTATION_BOTH
    }

    ORIENTATION_FROM_STR_MAP = {
        ORIENTATION_UP: 'up',
        ORIENTATION_DN: 'down',
        ORIENTATION_BOTH: 'both'
    }

    TRADE_QUANTITY_NORMAL = 0                # use normal trade quantity from the instrument
    TRADE_QUANTITY_SPECIFIC = 1              # use the context defined quantity, not the one from the instrument
    TRADE_QUANTITY_REINVEST_MAX_LAST = 2     # reuse the last exited quantity for the next trades
    TRADE_QUANTITY_INC_STEP = 3              # at each exit increase the quantity of a fixed size
    TRADE_QUANTITY_MANAGED = 4               # managed by a handler

    TRADE_QUANTITY = {
        'normal': TRADE_QUANTITY_NORMAL,
        'specific': TRADE_QUANTITY_SPECIFIC,
        'reinvest-max-last': TRADE_QUANTITY_REINVEST_MAX_LAST,
        'increment-step': TRADE_QUANTITY_INC_STEP,
        'managed': TRADE_QUANTITY_MANAGED
    }

    TRADE_QUANTITY_FROM_STR_MAP = {
        TRADE_QUANTITY_NORMAL: 'normal',
        TRADE_QUANTITY_SPECIFIC: 'specific',
        TRADE_QUANTITY_REINVEST_MAX_LAST: 'reinvest-max-last',
        TRADE_QUANTITY_INC_STEP: 'increment-step',
        TRADE_QUANTITY_MANAGED: 'managed'
    }

    def __init__(self, name: str):
        super().__init__()

        self.name = name
        self.mode = StrategyTraderContext.MODE_NONE
        self.min_profit = 0.0  # in percentile

        self.compiled = False

        self.entry = EXEntry()
        self.take_profit = EXTakeProfit()
        self.stop_loss = EXStopLoss()
        self.dynamic_take_profit = None
        self.dynamic_stop_loss = None
        self.breakeven = None

        self.pre_signal = None   # runtime current pre-signal
        self.last_signal = None  # runtime last generated strategy signal

        self.long_call = None    # callable long method
        self.short_call = None   # callable short method

        self.max_trades = 0  # >0 limit the number of trade for the context

        self.trade_quantity_type = StrategyTraderContext.TRADE_QUANTITY_NORMAL  # mode
        self.trade_quantity = 0.0       # last realized max trade exit quantity or specific value
        self.trade_quantity_step = 0.0  # step of increment

    def loads(self, strategy_trader, params: dict):
        self.max_trades = max(0, params.get('max-trades', 0))
        self.min_profit = max(0.0, params.get('min-profit', 0.0)) * 0.01

    def compile(self, strategy_trader):
        pass

    def dumps(self) -> dict:
        results = {
                'id': self.name,  # for compatibility
                'name': self.name,
                'mode': self.mode_to_str(),
                'min-profit': self.min_profit,
                'max-trades': self.max_trades,
                'trade-quantity-type': self.trade_quantity_type_to_str(),
                'trade-quantity': self.trade_quantity,
                'trade-quantity-step': self.trade_quantity_step
        }

        if self.entry:
            results['entry'] = self.entry.dumps()
        if self.take_profit:
            results['take-profit'] = self.take_profit.dumps()
        if self.stop_loss:
            results['stop-loss'] = self.stop_loss.dumps()
        if self.breakeven:
            results['breakeven'] = self.breakeven.dumps()
        if self.dynamic_stop_loss:
            results['dynamic-stop-loss'] = self.dynamic_stop_loss.dumps()
        if self.dynamic_take_profit:
            results['dynamic-take-profit'] = self.dynamic_take_profit.dumps()

        return results

    def update(self, timestamp):
        # update EX
        if self.breakeven:
            self.breakeven.update(timestamp)

        if self.stop_loss:
            self.stop_loss.update(timestamp)

        if self.take_profit:
            self.take_profit.update(timestamp)

        if self.dynamic_stop_loss:
            self.dynamic_stop_loss.update(timestamp)

        if self.dynamic_take_profit:
            self.dynamic_take_profit.update(timestamp)

    def compute_quantity(self, strategy_trader) -> float:
        if self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_NORMAL:
            # quantity is defined by instrument
            return strategy_trader.instrument.trade_quantity
        elif self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_MANAGED:
            # quantity is defined by context, else by instrument
            return self.trade_quantity if self.trade_quantity > 0 else strategy_trader.instrument.trade_quantity
        elif self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_SPECIFIC:
            # quantity is defined by context
            return self.trade_quantity
        elif self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_REINVEST_MAX_LAST:
            # quantity is defined by context, else by instrument
            return self.trade_quantity if self.trade_quantity > 0 else strategy_trader.instrument.trade_quantity
        elif self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_INC_STEP:
            # quantity is defined by context, else by instrument
            return self.trade_quantity if self.trade_quantity > 0 else strategy_trader.instrument.trade_quantity

        return 0.0

    def mode_to_str(self) -> str:
        if self.mode == StrategyTraderContext.MODE_NONE:
            return 'none'
        elif self.mode == StrategyTraderContext.MODE_SIGNAL:
            return 'signal'
        elif self.mode == StrategyTraderContext.MODE_TRADE:
            return 'trade'

        return 'unknown'

    def trade_quantity_type_to_str(self) -> str:
        return StrategyTraderContext.TRADE_QUANTITY_FROM_STR_MAP.get(self.trade_quantity_type)

    def modify_trade_quantity_type(self, instrument, trade_quantity_type: str, value: float = 0.0) -> bool:
        """
        @param instrument
        @param trade_quantity_type str String trade quantity type.
        @param value trade quantity for specific type, or step value
        """
        trade_quantity_type = StrategyTraderContext.TRADE_QUANTITY.get(trade_quantity_type)

        if trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_NORMAL:
            self.trade_quantity = 0.0
            self.trade_quantity_step = 0.0
            self.trade_quantity_type = trade_quantity_type

            return True

        elif trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_SPECIFIC:
            if value >= 0.0:
                self.trade_quantity = value
                self.trade_quantity_step = 0.0
                self.trade_quantity_type = trade_quantity_type

                return True

        elif trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_INC_STEP:
            if value > 0.0:
                if self.trade_quantity <= 0.0:
                    # initialize
                    self.trade_quantity = instrument.trade_quantity

                self.trade_quantity_step = value
                self.trade_quantity_type = trade_quantity_type

                return True

        elif trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_MANAGED:
            if value > 0.0:
                self.trade_quantity_step = value
                self.trade_quantity_type = trade_quantity_type

                return True

        elif trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_REINVEST_MAX_LAST:
            if self.trade_quantity <= 0.0:
                # initialize
                self.trade_quantity = instrument.trade_quantity

            self.trade_quantity_step = 0.0
            self.trade_quantity_type = trade_quantity_type

            return True

        return False

    def modify_trade_quantity(self, value: float = 0.0) -> bool:
        """
        Only if TRADE_QUANTITY_SPECIFIC is the current trade_quantity_type.
        @param value trade quantity for specific type, or step value
        @return True if value is greater or equal to zero and current trade quantity mode is set to specific.
        """
        if self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_SPECIFIC:
            if value >= 0.0:
                self.trade_quantity = value
                return True

        return False

    def modify_trade_step(self, value: float = 0.0) -> bool:
        """
        Only if TRADE_QUANTITY_INC_STEP is the current trade_quantity_type.
        @param value trade quantity step for specific type, or step value
        """
        if self.trade_quantity_type == StrategyTraderContext.TRADE_QUANTITY_INC_STEP:
            if value >= 0.0:
                self.trade_quantity_step = value
                return True

        return False

    def load_dynamic_take_profit(self, strategy_trader, params):
        if 'dynamic-take-profit' in params:
            dynamic_take_profit = EXTakeProfit()
            dynamic_take_profit.loads(strategy_trader, params['dynamic-take-profit'])

            if dynamic_take_profit.timeframe or dynamic_take_profit.num_bars:
                return dynamic_take_profit

    def load_dynamic_stop_loss(self, strategy_trader, params):
        if 'dynamic-stop-loss' in params:
            dynamic_stop_loss = EXStopLoss()
            dynamic_stop_loss.loads(strategy_trader, params['dynamic-stop-loss'])

            if dynamic_stop_loss.timeframe or dynamic_stop_loss.num_bars:
                return dynamic_stop_loss

    def load_breakeven(self, strategy_trader, params):
        if 'breakeven' in params:
            breakeven = EXBreakeven()
            breakeven.loads(strategy_trader, params['breakeven'])

            if breakeven.timeframe or breakeven.num_bars:
                return breakeven

    def compute_signal(self, instrument: Instrument, timestamp: float,
                       prev_price: float, last_price: float) -> Optional[StrategySignal]:
        """
        To be overridden to compute a signal par context at time.
        @param instrument: Related instrument
        @param timestamp: Current timestamp
        @param prev_price: Previous last_price value
        @param last_price: Last market traded price
        @return:
        """
        if not self.compiled:
            return None

        return None

    #
    # trade management
    #

    def update_trade(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade):
        """
        Overload it to update the targets of a trade.
        @param strategy_trader:
        @param trade:
        @note Do the work if trade.is_active() and when it is not.
        In addition, this method can re-evaluate the legitimacy of the existence of an opened (but non filled) trade
        and cancel it if necessary.
        """
        pass

    def custom_dynamic_stop_loss(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade):
        """
        Overload it to update the stop-loss of a trade.
        This method is called only if the method is set to custom.
        @param strategy_trader:
        @param trade:
        @return New stop-loss price or 0 if no changes.
        """
        return 0.0

    def custom_dynamic_take_profit(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade):
        """
        Overload it to update the take-profit of a trade.
        This method is called only if the method is set to custom.
        @param strategy_trader:
        @param trade:
        @return New take-profit price or 0 if no changes.
        """
        return 0.0

    def apply_breakeven(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade, hard=True):
        """
        Default breakeven policy. It checks if the breakeven apply to a trade and modify the stop-loss price
        if necessary according to the rules.
        @param strategy_trader:
        @param trade:
        @param hard:
        """
        if not trade or not strategy_trader or not self.breakeven:
            return

        if not self.breakeven.consolidated:
            # only if timeframe is configured
            return

        # never apply if the stop price is already defined at even or in profit
        if trade.stop_loss > 0.0 and ((trade.is_long and trade.stop_loss >= trade.entry_price) or
                                      (trade.is_short and trade.stop_loss <= trade.entry_price)):
            return

        close_exec_price = strategy_trader.instrument.close_exec_price(trade.dir)
        if not close_exec_price:
            return

        # minimal distance before apply. gross distance in that case.
        if not self.breakeven.check_min_distance_from_entry(trade, close_exec_price):
            return

        new_stop_price = self.breakeven.stop_loss_from_entry_price(trade)

        if new_stop_price > 0.0:
            new_stop_price = strategy_trader.instrument.adjust_price(new_stop_price)
            try:
                strategy_trader.trade_modify_stop_loss(trade, new_stop_price, hard)
            except Exception as e:
                error_logger.error(repr(e))

    def apply_dynamic_stop_loss(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade, hard=False):
        """
        Default dynamic stop-loss policy. It checks if the dynamic stop-loss policy apply to a trade and modify
        the stop-loss price if necessary.
        If the mode is set to PRICE_CUSTOM then custom_dynamic_stop_loss is called in place.

        If a breakeven is configured the minimum distance of breakeven must be reached else it will reject any
        changes.

        @param strategy_trader:
        @param trade:
        @param hard:
        """
        if not trade or not strategy_trader or not self.dynamic_stop_loss:
            return

        # only if timeframe is configured
        if not self.dynamic_stop_loss.consolidated:
            return

        close_exec_price = strategy_trader.instrument.close_exec_price(trade.dir)
        if not close_exec_price:
            return

        # check for min distance from breakeven if provided (gross distance)
        if self.breakeven:
            if not self.breakeven.check_min_distance_from_entry(trade, close_exec_price):
                return

        # last stop must be at minimal defined distance (gross distance)
        if not self.dynamic_stop_loss.check_min_distance_from_stop(trade, close_exec_price):
            return

        new_stop_price = 0.0

        if self.dynamic_stop_loss.type == self.PRICE_FIXED:
            # fixed distance without offset or spread
            new_stop_price = self.dynamic_stop_loss.stop_loss_from_price(trade, close_exec_price)

        elif self.dynamic_stop_loss.type == self.PRICE_CUSTOM:
            # custom method call
            new_stop_price = self.custom_dynamic_stop_loss(strategy_trader, trade)

        # do nothing if stop is increased in absolute (only safer)
        # and this avoids flooding due to possible imprecision error
        if new_stop_price > 0.0:
            if trade.direction > 0 and new_stop_price <= trade.stop_loss:
                new_stop_price = 0.0
            elif trade.direction < 0 and new_stop_price >= trade.stop_loss:
                new_stop_price = 0.0

        if new_stop_price > 0.0:
            new_stop_price = strategy_trader.instrument.adjust_price(new_stop_price)
            if new_stop_price != trade.stop_loss:
                try:
                    strategy_trader.trade_modify_stop_loss(trade, new_stop_price, hard)
                except Exception as e:
                    error_logger.error(repr(e))

    def apply_dynamic_take_profit(self, strategy_trader: StrategyTraderBase, trade: StrategyTrade, hard=True):
        """
        Default dynamic take-profit policy. It checks if the dynamic take-profit policy apply to a trade and modify
        the take-profit price if necessary.
        If the mode is set to PRICE_CUSTOM then custom_dynamic_take_profit is called in place.

        @param strategy_trader:
        @param trade:
        @param hard:
        """
        if not trade or not strategy_trader or not self.dynamic_take_profit:
            return

        if not self.dynamic_take_profit.consolidated:
            # only if timeframe is configured
            return

        close_exec_price = strategy_trader.instrument.close_exec_price(trade.dir)
        if not close_exec_price:
            return

        # last stop must be at minimal defined distance (gross distance)
        if not self.dynamic_take_profit.check_min_distance_from_limit(trade, close_exec_price):
            return

        new_take_profit_price = 0.0

        if self.dynamic_take_profit.type == self.PRICE_FIXED:
            # fixed distance without offset or spread
            new_take_profit_price = self.dynamic_take_profit.take_profit_from_price(trade, close_exec_price)

        elif self.dynamic_stop_loss.type == self.PRICE_CUSTOM:
            # custom method call
            new_take_profit_price = self.custom_dynamic_take_profit(strategy_trader, trade)

        # do nothing if take-profit is decreased in absolute (only safer)
        # and this avoids flooding due to possible imprecision error
        if new_take_profit_price > 0.0:
            if trade.direction > 0 and new_take_profit_price <= trade.take_profit:
                new_take_profit_price = 0.0
            elif trade.direction < 0 and new_take_profit_price >= trade.take_profit:
                new_take_profit_price = 0.0

        if new_take_profit_price > 0.0:
            new_take_profit_price = strategy_trader.instrument.adjust_price(new_take_profit_price)
            if new_take_profit_price != trade.take_profit:
                try:
                    strategy_trader.trade_modify_take_profit(trade, new_take_profit_price, hard)
                except Exception as e:
                    error_logger.error(repr(e))

    #
    # context state reporting
    #

    def report_state_members(self) -> Tuple:
        """
        Return a tuple of tuples with the name and format of the value to report.
        @note Must be of the same length as return by report_state method.
        @note Works with mode 3.
        """
        return ("str", "Name"),

    def report_state(self, instrument: Instrument) -> Tuple:
        """
        Return a tuple of tuples with the data value to report.
        @note Must be of the same length as return by report_state_members method.
        @note Works with mode 3.
        """
        return self.name,

    def report_parameters_members(self) -> Tuple:
        """
        Return a tuple of tuples with the name and format of the value to report.
        @note Must be of the same length as return by report_parameters method.
        @note Works with mode 4.
        """
        return ("str", "Name"),

    def report_parameters(self, instrument: Instrument) -> Tuple:
        """
        Return a tuple of tuples with the data value to report.
        @note Must be of the same length as return by report_state_members method.
        @note Works with mode 4.
        """
        return self.name,
