# todo one file per command

def cmd_trade_entry(self, strategy_trader, data):
    """
    Create a new trade according data on given strategy_trader.
    """
    results = {
        'messages': [],
        'error': False
    }

    # command data
    direction = data.get('direction', Order.LONG)
    method = data.get('method', 'market')
    limit_price = data.get('limit-price')
    trigger_price = data.get('trigger-price')
    quantity_rate = data.get('quantity-rate', 1.0)
    stop_loss = data.get('stop-loss', 0.0)
    take_profit = data.get('take-profit', 0.0)
    stop_loss_price_mode = data.get('stop-loss-price-mode', 'price')
    take_profit_price_mode = data.get('take-profit-price-mode', 'price')
    timeframe = data.get('timeframe', Instrument.TF_4HOUR)
    leverage = data.get('leverage', 1.0)
    hedging = data.get('hedging', True)
    margin_trade = data.get('margin-trade', False)
    entry_timeout = data.get('entry-timeout', None)
    context = data.get('context', None)

    if quantity_rate <= 0.0:
        results['messages'].append("Missing or empty quantity.")
        results['error'] = True

    if method not in ('market', 'limit', 'trigger'):
        results['messages'].append("Invalid price method (market, limit, trigger).")
        results['error'] = True

    if method != 'market' and not limit_price:
        results['messages'].append("Price is missing.")
        results['error'] = True

    if results['error']:
        return results

    if method == 'market':
        order_type = Order.ORDER_MARKET
    elif method == 'limit':
        order_type = Order.ORDER_LIMIT
    elif method == 'trigger':
        order_type = Order.ORDER_STOP
    else:
        order_type = Order.ORDER_MARKET

    order_quantity = 0.0

    trader = self.trader()

    # need a valid price to compute the quantity
    price = limit_price or strategy_trader.instrument.open_exec_price(direction)
    trade = None

    if strategy_trader.instrument.has_spot and not margin_trade:
        # market support spot and margin option is not defined
        trade = StrategyAssetTrade(timeframe)

        # ajust max quantity according to free asset of quote, and convert in asset base quantity
        if trader.has_asset(strategy_trader.instrument.quote):
            qty = strategy_trader.instrument.trade_quantity*quantity_rate

            if trader.has_quantity(strategy_trader.instrument.quote, qty):
                order_quantity = strategy_trader.instrument.adjust_quantity(qty / price)  # and adjusted to 0/max/step
            else:
                results['error'] = True
                results['messages'].append("Not enought free quote asset %s, has %s but need %s" % (
                        strategy_trader.instrument.quote,
                        strategy_trader.instrument.format_quantity(trader.asset(strategy_trader.instrument.quote).free),
                        strategy_trader.instrument.format_quantity(qty)))

    elif strategy_trader.instrument.has_margin and strategy_trader.instrument.has_position:
        trade = StrategyPositionTrade(timeframe)

        if strategy_trader.instrument.trade_quantity_mode == Instrument.TRADE_QUANTITY_QUOTE_TO_BASE:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate/price)
        else:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate)

        if not trader.has_margin(strategy_trader.instrument.market_id, order_quantity, price):
            results['error'] = True
            results['messages'].append("Not enought margin, need %s" % (trader.get_needed_margin(strategy_trader.instrument.market_id, order_quantity, price),))

    elif strategy_trader.instrument.has_margin and strategy_trader.instrument.indivisible_position:
        trade = StrategyIndMarginTrade(timeframe)

        if strategy_trader.instrument.trade_quantity_mode == Instrument.TRADE_QUANTITY_QUOTE_TO_BASE:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate/price)
        else:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate)

        if not trader.has_margin(strategy_trader.instrument.market_id, order_quantity, price):
            results['error'] = True
            results['messages'].append("Not enought margin, need %s" % (trader.get_needed_margin(strategy_trader.instrument.market_id, order_quantity, price),))

    elif strategy_trader.instrument.has_margin and not strategy_trader.instrument.indivisible_position and not strategy_trader.instrument.has_position:
        trade = StrategyMarginTrade(timeframe)

        if strategy_trader.instrument.trade_quantity_mode == Instrument.TRADE_QUANTITY_QUOTE_TO_BASE:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate/price)
        else:
            order_quantity = strategy_trader.instrument.adjust_quantity(strategy_trader.instrument.trade_quantity*quantity_rate)

        if not trader.has_margin(strategy_trader.instrument.market_id, order_quantity, price):
            results['error'] = True
            results['messages'].append("Not enought margin, need %s" % (trader.get_needed_margin(strategy_trader.instrument.market_id, order_quantity, price),))

    else:
        results['error'] = True
        results['messages'].append("Unsupported market type")

    if order_quantity <= 0 or order_quantity * price < strategy_trader.instrument.min_notional:
        results['error'] = True
        results['messages'].append("Min notional not reached (%s)" % strategy_trader.instrument.min_notional)

    if results['error']:
        return results

    order_price = strategy_trader.instrument.adjust_price(price)

    #
    # compute stop-loss and take-profit price depending of their respective mode
    #

    if stop_loss_price_mode == "percent":
        if direction > 0:
            stop_loss = strategy_trader.instrument.adjust_price(order_price * (1.0 - stop_loss * 0.01))
        elif direction < 0:
            stop_loss = strategy_trader.instrument.adjust_price(order_price * (1.0 + stop_loss * 0.01))

    elif stop_loss_price_mode == "pip":
        if direction > 0:
            stop_loss = strategy_trader.instrument.adjust_price(order_price - stop_loss * strategy_trader.instruments.value_per_pip)
        elif direction < 0:
            stop_loss = strategy_trader.instrument.adjust_price(order_price + stop_loss * strategy_trader.instruments.value_per_pip)

    if take_profit_price_mode == "percent":
        if direction > 0:
            take_profit = strategy_trader.instrument.adjust_price(order_price * (1.0 + take_profit * 0.01))
        elif direction < 0:
            take_profit = strategy_trader.instrument.adjust_price(order_price * (1.0 - take_profit * 0.01))

    elif take_profit_price_mode == "pip":
        if direction > 0:
            take_profit = strategy_trader.instrument.adjust_price(order_price + take_profit * strategy_trader.instruments.value_per_pip)
        elif direction < 0:
            take_profit = strategy_trader.instrument.adjust_price(order_price - take_profit * strategy_trader.instruments.value_per_pip)

    #
    # check stop-loss and take-profit and reject if not consistent
    #

    if stop_loss < 0.0:
        results['error'] = True
        results['messages'].append("Rejected trade on %s:%s because the stop-loss is negative" % (self.identifier, strategy_trader.instrument.market_id))

        return results

    if take_profit < 0.0:
        results['error'] = True
        results['messages'].append("Rejected trade on %s:%s because the take-profit is negative" % (self.identifier, strategy_trader.instrument.market_id))

        return results

    if direction > 0:
        if stop_loss > order_price:
            results['error'] = True
            results['messages'].append("Rejected trade on %s:%s because the stop-loss is above the entry price" % (self.identifier, strategy_trader.instrument.market_id))

            return results

        if take_profit < order_price:
            results['error'] = True
            results['messages'].append("Rejected trade on %s:%s because the take-profit is below the entry price" % (self.identifier, strategy_trader.instrument.market_id))

            return results

    elif direction < 0:
        if stop_loss < order_price:
            results['error'] = True
            results['messages'].append("Rejected trade on %s:%s because the stop-loss is below the entry price" % (self.identifier, strategy_trader.instrument.market_id))

            return results

        if take_profit > order_price:
            results['error'] = True
            results['messages'].append("Rejected trade on %s:%s because the take-profit is above the entry price" % (self.identifier, strategy_trader.instrument.market_id))

            return results

    if trade:
        # user managed trade
        trade.set_user_trade()

        if entry_timeout:
            # entry timeout expiration defined (could be overrided by trade context if specified)
            trade.entry_timeout = entry_timeout

        if context:
            if not strategy_trader.set_trade_context(trade, context):
                # add an error result message
                results['error'] = True
                results['messages'].append("Rejected trade on %s:%s because the context was not found" % (self.identifier, strategy_trader.instrument.market_id))

                return results

        # the new trade must be in the trades list if the event comes before, and removed after only it failed
        strategy_trader.add_trade(trade)

        if trade.open(trader, strategy_trader.instrument, direction, order_type, order_price, order_quantity,
                      take_profit, stop_loss, leverage=leverage, hedging=hedging):

            # add a success result message
            results['messages'].append("Created trade %i on %s:%s" % (trade.id, self.identifier, strategy_trader.instrument.market_id))
        else:
            strategy_trader.remove_trade(trade)

            # add an error result message
            results['error'] = True
            results['messages'].append("Rejected trade on %s:%s" % (self.identifier, strategy_trader.instrument.market_id))

    return results

def cmd_trade_exit(self, strategy_trader, data):
    """
    Exit an existing trade according data on given strategy_trader.

    @note If trade-id is -1 assume the last trade.
    """
    results = {
        'messages': [],
        'error': False
    }

    # retrieve the trade
    trade_id = -1

    try:
        trade_id = int(data.get('trade-id'))
    except Exception:
        results['error'] = True
        results['messages'].append("Invalid trade identifier")

    if results['error']:
        return results

    trade = None

    trader = self.trader()

    with strategy_trader._mutex:
        if trade_id == -1 and strategy_trader.trades:
            trade = strategy_trader.trades[-1]
        else:
            for t in strategy_trader.trades:
                if t.id == trade_id:
                    trade = t
                    break

        if trade:
            price = strategy_trader.instrument.close_exec_price(trade.direction)

            if not trade.is_active():
                # cancel open
                trade.cancel_open(trader, strategy_trader.instrument)

                # add a success result message
                results['messages'].append("Cancel trade %i on %s:%s" % (trade.id, self.identifier, strategy_trader.instrument.market_id))
            else:
                # close or cancel
                trade.close(trader, strategy_trader.instrument)

                # add a success result message
                results['messages'].append("Close trade %i on %s:%s at market price %s" % (
                    trade.id, self.identifier, strategy_trader.instrument.market_id, strategy_trader.instrument.format_price(price)))
        else:
            results['error'] = True
            results['messages'].append("Invalid trade identifier %i" % trade_id)

    return results

def cmd_trade_clean(self, strategy_trader, data):
    """
    Clean an existing trade according data on given strategy_trader.

    @note If trade-id is -1 assume the last trade.
    """
    results = {
        'messages': [],
        'error': False
    }

    # retrieve the trade
    trade_id = -1

    try:
        trade_id = int(data.get('trade-id'))
    except Exception:
        results['error'] = True
        results['messages'].append("Invalid trade identifier")

    if results['error']:
        return results

    trade = None
    trader = self.trader()

    with strategy_trader._mutex:
        if trade_id == -1 and strategy_trader.trades:
            trade = strategy_trader.trades[-1]
        else:
            for t in strategy_trader.trades:
                if t.id == trade_id:
                    trade = t
                    break

        if trade:
            # remove orders
            trade.remove(trader, strategy_trader.instrument)

            # and the trade, don't keet it for history because unqualifiable
            strategy_trader.remove_trade(trade)

            # add a success result message
            results['messages'].append("Force remove trade %i on %s:%s" % (trade.id, self.identifier, strategy_trader.instrument.market_id))
        else:
            results['error'] = True
            results['messages'].append("Invalid trade identifier %i" % trade_id)

    return results

def cmd_trade_modify(self, strategy_trader, data):
    """
    Modify a trade according data on given strategy_trader.

    @note If trade-id is -1 assume the last trade.
    """
    results = {
        'messages': [],
        'error': False
    }

    # retrieve the trade
    trade_id = -1
    action = ""

    try:
        trade_id = int(data.get('trade-id'))
        action = data.get('action')
    except Exception:
        results['error'] = True
        results['messages'].append("Invalid trade identifier")

    if results['error']:
        return results

    trade = None

    with strategy_trader._mutex:
        if trade_id == -1 and strategy_trader.trades:
            trade = strategy_trader.trades[-1]
        else:
            for t in strategy_trader.trades:
                if t.id == trade_id:
                    trade = t
                    break

        if trade:
            # modify SL
            if action == 'stop-loss' and 'stop-loss' in data and type(data['stop-loss']) is float:
                if data['stop-loss'] > 0.0:
                    if trade.has_stop_order() or data.get('force', False):
                        trade.modify_stop_loss(self.trader(), strategy_trader.instrument, data['stop-loss'])
                    else:
                        trade.sl = data['stop-loss']
                else:
                    results['error'] = True
                    results['messages'].append("Take-profit must be greater than 0 on trade %i" % trade.id)

            # modify TP
            elif action == 'take-profit' and 'take-profit' in data and type(data['take-profit']) is float:
                if data['take-profit'] > 0.0:
                    if trade.has_limit_order() or data.get('force', False):
                        trade.modify_take_profit(self.trader(), strategy_trader.instrument, data['take-profit'])
                    else:
                        trade.tp = data['take-profit']
                else:
                    results['error'] = True
                    results['messages'].append("Take-profit must be greater than 0 on trade %i" % trade.id)

            # add operation
            elif action == 'add-op':
                op_name = data.get('operation', "")

                if op_name in self.service.tradeops:
                    try:
                        # instanciate the operation
                        operation = self.service.tradeops[op_name]()

                        # and define the parameters
                        operation.init(data)

                        if operation.check(trade):
                            # append the operation to the trade
                            trade.add_operation(operation)
                        else:
                            results['error'] = True
                            results['messages'].append("Operation checking error %s on trade %i" % (op_name, trade.id))

                    except Exception as e:
                        results['error'] = True
                        results['messages'].append(repr(e))
                else:
                    results['error'] = True
                    results['messages'].append("Unsupported operation %s on trade %i" % (op_name, trade.id))

            # remove operation
            elif action == 'del-op':
                trade_operation_id = -1

                if 'operation-id' in data and type(data.get('operation-id')) is int:
                    trade_operation_id = data['operation-id']

                if not trade.remove_operation(trade_operation_id):
                    results['error'] = True
                    results['messages'].append("Unknown operation-id on trade %i" % trade.id)
            else:
                # unsupported action
                results['error'] = True
                results['messages'].append("Unsupported action on trade %i" % trade.id)

        else:
            results['error'] = True
            results['messages'].append("Invalid trade identifier %i" % trade_id)

    return results

def cmd_trade_assign(self, strategy_trader, data):
    """
    Assign a free quantity of an asset to a newly created trade according data on given strategy_trader.
    """
    results = {
        'messages': [],
        'error': False
    }

    # command data
    direction = data.get('direction', Order.LONG)
    entry_price = data.get('entry-price', 0.0)
    quantity = data.get('quantity', 0.0)
    stop_loss = data.get('stop-loss', 0.0)
    take_profit = data.get('take-profit', 0.0)
    timeframe = data.get('timeframe', Instrument.TF_4HOUR)

    if quantity <= 0.0:
        results['messages'].append("Missing or empty quantity.")
        results['error'] = True

    if entry_price <= 0:
        results['messages'].append("Invalid entry price.")
        results['error'] = True

    if stop_loss and stop_loss > entry_price:
        results['messages'].append("Stop-loss price must be lesser than entry price.")
        results['error'] = True

    if take_profit and take_profit < entry_price:
        results['messages'].append("Take-profit price must be greater then entry price.")
        results['error'] = True

    if direction != Order.LONG:
        results['messages'].append("Only trade long direction is allowed.")
        results['error'] = True

    trader = self.trader()

    if not trader.has_quantity(strategy_trader.instrument.base, quantity):
        results['messages'].append("No enought free asset quantity.")
        results['error'] = True

    # @todo trade type
    if not strategy_trader.instrument.has_spot:
        results['messages'].append("Only allowed on a spot market.")
        results['error'] = True

    if results['error']:
        return results

    trade = StrategyAssetTrade(timeframe)

    # user managed trade
    trade.set_user_trade()

    trade._entry_state = StrategyAssetTrade.STATE_FILLED
    trade._exit_state = StrategyAssetTrade.STATE_NEW
    
    trade.dir = Order.LONG
    trade.op = entry_price
    trade.oq = quantity

    trade.tp = take_profit
    trade.sl = stop_loss        

    trade.eot = time.time()

    trade.aep = entry_price

    trade.e = quantity

    strategy_trader.add_trade(trade)

    results['messages'].append("Assigned trade %i on %s:%s" % (trade.id, self.identifier, strategy_trader.instrument.market_id))

    return results

def cmd_trade_info(self, strategy_trader, data):
    """
    Get trade info according data on given strategy_trader.

    @note If trade-id is -1 assume the last trade.
    """        
    results = {
        'messages': [],
        'error': False
    }

    trade_id = -1

    try:
        trade_id = int(data.get('trade-id'))
    except Exception:
        results['error'] = True
        results['messages'].append("Invalid trade identifier")

    if results['error']:
        return results

    trade = None

    with strategy_trader._mutex:
        if trade_id == -1 and strategy_trader.trades:
            trade = strategy_trader.trades[-1]
        else:
            for t in strategy_trader.trades:
                if t.id == trade_id:
                    trade = t
                    break

        if trade:
            results['messages'].append("Trade %i, list %i operations:" % (trade.id, len(trade.operations)))

            # @todo or as table using operation.parameters() dict
            for operation in trade.operations:
                results['messages'].append(" - #%i: %s" % (operation.id, operation.str_info()))
        else:
            results['error'] = True
            results['messages'].append("Invalid trade identifier %i" % trade_id)

    return results

def cmd_trade_close_all(self, strategy_trader, data):
    """
    Close any active trade for the strategy trader, at market, deleted related orders.
    """
    results = {
        'messages': [],
        'error': False
    }

    # @todo

    return results

def cmd_trade_sell_all(self, strategy_trader, data):
    """
    Assign a free quantity of an asset to a newly created trade according data on given strategy_trader.
    """
    results = {
        'messages': [],
        'error': False
    }

    # @todo

    return results

def cmd_strategy_trader_modify(self, strategy_trader, data):
    """
    Modify a strategy-trader state, a region or an alert.
    """        
    results = {
        'messages': [],
        'error': False
    }

    action = ""
    expiry = 0
    countdown = -1
    timeframe = 0

    with strategy_trader._mutex:
        try:
            action = data.get('action')
        except Exception:
            results['error'] = True
            results['messages'].append("Invalid trader action")

        if action == "add-region":
            region_name = data.get('region', "")

            try:
                stage = int(data.get('stage', 0))
                direction = int(data.get('direction', 0))
                created = float(data.get('created', 0.0))
                expiry = float(data.get('expiry', 0.0))

                if 'timeframe' in data and type(data['timeframe']) is str:
                    timeframe = timeframe_from_str(data['timeframe'])

            except ValueError:
                results['error'] = True
                results['messages'].append("Invalid parameters")

            if not results['error']:
                if region_name in self.service.regions:
                    try:
                        # instanciate the region
                        region = self.service.regions[region_name](created, stage, direction, timeframe)

                        if expiry:
                            region.set_expiry(expiry)

                        # and defined the parameters
                        region.init(data)

                        if region.check():
                            # append the region to the strategy trader
                            strategy_trader.add_region(region)
                        else:
                            results['error'] = True
                            results['messages'].append("Region checking error %s" % (region_name,))

                    except Exception as e:
                        results['error'] = True
                        results['messages'].append(repr(e))
                else:
                    results['error'] = True
                    results['messages'].append("Unsupported region %s" % (region_name,))

        elif action == "del-region":
            try:
                region_id = int(data.get('region-id', -1))
            except Exception:
                results['error'] = True
                results['messages'].append("Invalid region identifier format")

            if region_id >= 0:
                if not strategy_trader.remove_region(region_id):
                    results['messages'].append("Invalid region identifier")

        elif action == 'add-alert':
            alert_name = data.get('alert', "")

            try:
                created = float(data.get('created', 0.0))
                expiry = float(data.get('expiry', 0.0))
                countdown = int(data.get('countdown', -1))
                timeframe = 0

                if 'timeframe' in data:
                    if type(data['timeframe']) is str:
                        timeframe = timeframe_from_str(data['timeframe'])
                    elif type(data['timeframe']) in (float, int):
                        timeframe = data['timeframe']

            except ValueError:
                results['error'] = True
                results['messages'].append("Invalid parameters")

            if not results['error']:
                if alert_name in self.service.alerts:
                    try:
                        # instanciate the alert
                        alert = self.service.alerts[alert_name](created, timeframe)
                        alert.set_countdown(countdown)

                        if expiry:
                            alert.set_expiry(expiry)                         

                        # and defined the parameters
                        alert.init(data)

                        if alert.check():
                            # append the alert to the strategy trader
                            strategy_trader.add_alert(alert)
                        else:
                            results['error'] = True
                            results['messages'].append("Alert checking error %s" % (alert_name,))

                    except Exception as e:
                        results['error'] = True
                        results['messages'].append(repr(e))
                else:
                    results['error'] = True
                    results['messages'].append("Unsupported alert %s" % (alert_name,))

        elif action == 'del-alert':
            try:
                alert_id = int(data.get('alert-id', -1))
            except Exception:
                results['error'] = True
                results['messages'].append("Invalid alert identifier format")

            if alert_id >= 0:
                if not strategy_trader.remove_alert(alert_id):
                    results['messages'].append("Invalid alert identifier")

        elif action == "enable":
            if not strategy_trader.activity:
                strategy_trader.set_activity(True)
                results['messages'].append("Enabled strategy trader for market %s" % strategy_trader.instrument.market_id)
            else:
                results['messages'].append("Already enabled strategy trader for market %s" % strategy_trader.instrument.market_id)

        elif action == "disable":
            if strategy_trader.activity:
                strategy_trader.set_activity(False)
                results['messages'].append("Disabled strategy trader for market %s" % strategy_trader.instrument.market_id)
            else:
                results['messages'].append("Already disabled strategy trader for market %s" % strategy_trader.instrument.market_id)

        elif action == "set-quantity":
            quantity = 0.0
            max_factor = 1

            try:
                base_quantity = float(data.get('quantity', -1))
            except Exception:
                results['error'] = True
                results['messages'].append("Invalid quantity")

            try:
                max_factor = int(data.get('max-factor', 1))
            except Exception:
                results['error'] = True
                results['messages'].append("Invalid max factor")

            if quantity < 0.0:
                results['error'] = True
                results['messages'].append("Quantity must be greater than zero")

            if max_factor <= 0:
                results['error'] = True
                results['messages'].append("Max factor must be greater than zero")

            if quantity > 0.0 and strategy_trader.instrument.trade_quantity != quantity:
                strategy_trader.instrument.trade_quantity = quantity
                results['messages'].append("Modified trade quantity for %s to %s" % (strategy_trader.instrument.market_id, quantity))

            if max_factor > 0 and strategy_trader.instrument.trade_max_factor != max_factor:
                strategy_trader.instrument.max_factor = max_factor
                results['messages'].append("Modified trade quantity max factor for %s to %s" % (strategy_trader.instrument.market_id, max_factor))

        else:
            results['error'] = True
            results['messages'].append("Invalid action")

    return results

def cmd_strategy_trader_info(self, strategy_trader, data):
    """
    Get strategy-trader info or specific element if detail defined.
    """        
    results = {
        'messages': [],
        'error': False
    }

    detail = data.get('detail', "")
    region_id = -1

    if detail == "region":
        try:
            region_id = int(data.get('region-id'))
        except Exception:
            results['error'] = True
            results['messages'].append("Invalid region identifier")

    if results['error']:
        return results

    trade = None

    with strategy_trader._mutex:
        if detail == "region":
            if region_id >= 0:
                region = None

                for r in strategy_trader.regions:
                    if r.id == region_id:
                        region = r
                        break

                if region:
                    results['messages'].append("Stragegy trader %s region details:" % strategy_trader.instrument.market_id)
                    results['messages'].append(" - #%i: %s" % (region.id, region.str_info()))
                else:
                    results['error'] = True
                    results['messages'].append("Invalid region identifier %i" % region_id)

            else:
                results['messages'].append("Stragegy trader %s, list %i regions:" % (strategy_trader.instrument.market_id, len(strategy_trader.regions)))

                for region in strategy_trader.regions:
                    results['messages'].append(" - #%i: %s" % (region.id, region.str_info()))

        elif detail == "alert":
            # @todo
            pass

        elif detail == "status":
            # status
            results['messages'].append("Activity : %s" % ("enabled" if strategy_trader.activity else "disabled"))

        elif not detail or detail == "details":
            # no specific detail
            results['messages'].append("Stragegy trader %s details:" % strategy_trader.instrument.market_id)

            # status
            results['messages'].append("Activity : %s" % ("enabled" if strategy_trader.activity else "disabled"))

            # quantity
            results['messages'].append("Trade quantity : %s, max factor is x%s, mode is %s" % (
                strategy_trader.instrument.trade_quantity,
                strategy_trader.instrument.trade_max_factor,
                strategy_trader.instrument.trade_quantity_mode_to_str()
            ))

            # regions
            results['messages'].append("List %i regions:" % len(strategy_trader.regions))

            for region in strategy_trader.regions:
                results['messages'].append(" - #%i: %s" % (region.id, region.str_info()))
        else:
            results['error'] = True
            results['messages'].append("Invalid detail type name %s" % detail)

    return results

def cmd_trader_info(self, data):
    # info on the appliance
    if 'market-id' in data:
        with self._mutex:
            strategy_trader = self._strategy_traders.get(data['market-id'])
            if strategy_trader:
                Terminal.inst().message("Market %s of appliance %s identified by \\2%s\\0 is %s. Trade quantity is %s x%s" % (
                    data['market-id'], self.name, self.identifier, "active" if strategy_trader.activity else "paused",
                        strategy_trader.instrument.trade_quantity, strategy_trader.instrument.trade_max_factor),
                        view='content')
    else:
        Terminal.inst().message("Appliances %s is identified by \\2%s\\0" % (self.name, self.identifier), view='content')

        enabled = []
        disabled = []

        with self._mutex:
            for k, strategy_trader in self._strategy_traders.items():
                if strategy_trader.activity:
                    enabled.append(k)
                else:
                    disabled.append(k)

        if enabled:
            enabled = [e if i%10 else e+'\n' for i, e in enumerate(enabled)]
            Terminal.inst().message("Enabled instruments (%i): %s" % (len(enabled), " ".join(enabled)), view='content')

        if disabled:
            disabled = [e if i%10 else e+'\n' for i, e in enumerate(disabled)]
            Terminal.inst().message("Disabled instruments (%i): %s" % (len(disabled), " ".join(disabled)), view='content')

def cmd_strategy_trader_chart(self, strategy_trader, data):
    """
    Open as possible a process with chart of a specific sub-tader.
    """
    results = {
        'messages': [],
        'error': False
    }      

    monitor_url = data.get('monitor-url')
    timeframe = data.get('timeframe', 15*60)

    if results['error']:
        return results

    strategy_trader.subscribe_stream(timeframe)

    import subprocess
    p = subprocess.Popen(["python", "-m", "monitor.client.client", monitor_url[0], monitor_url[1]],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.PIPE, preexec_fn=os.setsid)

    return results

def cmd_strategy_trader_stream(self, strategy_trader, data):
    """
    Stream subscribe/unsubscribe to a market.
    """
    results = {
        'messages': [],
        'error': False
    }      

    timeframe = data.get('timeframe', None)
    action = data.get('action', "")
    typename = data.get('type', "")

    if action == "subscribe":
        if typename == "chart":
            strategy_trader.subscribe_stream(timeframe)
            results['messages'].append("Subscribed for stream %s %s %s" % (self.identifier, strategy_trader.instrument.market_id, timeframe or "default"))
        elif typename == "info":
            strategy_trader.subscribe_info()
            results['messages'].append("Subscribed for stream info %s %s" % (self.identifier, strategy_trader.instrument.market_id))
        else:
            # unsupported type
            results['error'] = True
            results['messages'].append("Unsupported stream %s for trader %s" % (typename, strategy_trader.instrument.market_id))

    elif action == "unsubscribe":
        if typename == "chart":            
            strategy_trader.unsubscribe_stream(timeframe)
            results['messages'].append("Unsubscribed from stream %s %s %s" % (self.identifier, strategy_trader.instrument.market_id, timeframe or "any"))
        elif typename == "info":
            strategy_trader.unsubscribe_info()
            results['messages'].append("Unsubscribed from stream info %s %s" % (self.identifier, strategy_trader.instrument.market_id))
        else:
            # unsupported type
            results['error'] = True
            results['messages'].append("Unsupported stream %s for trader %s" % (typename, strategy_trader.instrument.market_id))

    else:
         # unsupported action
        results['error'] = True
        results['messages'].append("Unsupported stream action %s for trader %s" % (action, strategy_trader.instrument.market_id))

    return results